\chapter{Memory Management}\label{sec:motivation} 
Part of this project is designing a compile time system for memory management.
Before describing how this system should work, an overview of existing memory
management techniques is given. Most programming languages have the ability to
dynamically allocate memory on the \textit{Heap}, which is a very useful
language feature.  However, the allocation, dereferencing, and freeing of heap
memory is problematic and this chapter will describe some of the issues with
heap allocated memory.

\section{Memory Usage and Computational Effects}
Most practical programming languages allow for storing and referencing areas
in memory. When an expression is evaluated, it may have an effect on memory as
well as returning a result. For example, an assignment statement in a programming
does not have any obvious result, but instead operates on values in an area of
memory that is accessible to other parts of the program. A langauge that allows
for these sorts of computational effects is referred to as \textit{impure} and
one of the goals for this project is to make these features safer to use.

\subsection{Stack and Heap Memory}
There are usually two kinds of memory that may be used to store values: stack
memory and heap memory. Both of these kinds of memory are refered to 

The basic operations needed in a system with memory allocation are:
\begin{description}
    \item[Allocation]
        Allocation refers to creating an area in memory to store the result of
        an expression. This is commonly seen is the form of variable
        assignment, for example \lstinline{x := ref 2 + 3;}. Here the expression
        \lstinline{2 + 3} is evaluated~\footnote{In languages with \textit{strict}
        evaluation, the expression is evaluated before the result is bound to
        the variable. This is not the case in all programming languages.} and
        the result is stored in the area of memory referred to by the variable
        \lstinline{x}. The value referred to by \lstinline{x} can then be used
        at some later point in the program. Variables may also be
        reassigned, for example \lstinline{y := x}. \lstinline{y} would then
        point to the same location that \lstinline{x} points to.
    \item[Dereference]
        Once an area of memory has been allocated, and is pointed to by a
        variable, some way of using the expression stored at that location is
        needed. Dereferencing refers to getting the expression stored at a
        location in memory. If we wanted to use \lstinline{x} at some point
        after the expression \lstinline{x := ref 2 + 3} had been evaluated,
        we could write \lstinline{!x}. The result of that expression would be
        5, because \lstinline{2 + 3} has been evaluated and the result stored
        in the area of memory that is pointed to by \lstinline{x}. The
        dereference operator, \lstinline{!E}, means ``go to the location in memory,
        \lstinline{E}, and get the value stored there''. 
    \item[Deallocation]
        Deallocation refers to freeing memory once it no longer needed. It is
        common to not want to use memory for the whole lifetime of a program.
        If memory was never freed programs would use far more memory than they
        needed, which would not be practical. In order to solve this problem
        memory may be deallocated once a variable goes out of scope, which is
        common for stack memory, or we could introduce an explicit deallocate
        operator, called \lstinline{free}. This operator would take a memory
        location and mark that location as unused so that a future allocation
        could reuse the same space.
\end{description}
most programming languages.  Expressions may be evaluated and stored in memory
for use at a later point. This operation is called allocation,  The variable may then be used in another expression
at a later point. Specifically, the \textit{heap} refers to an area
of memory that is set aside for dynamic allocation. Usually areas of memory
stored here can be allocated, dereferencd, and freed at any point in a program.


\section{Problems with Existing Memory Management Techniques}
Most programming languages allow for dynamic memory management where the
program can request portions of memory at run time and free that memory when it
is no longer required. This operation can be performed manually as in the case
of languages such as C or automatically in languages with a garbage collector
such as Java.

\subsection{Manual Memory Management: \lstinline{malloc} and \lstinline{free}}
Some languages rely on manual instructions inserted by the programmer in order
to allocate and deallocate regions of memory. Most implementations of the C
programming language provide a group of library functions for this purpose,
which include \lstinline{malloc} and \lstinline{free}. As mentioned, these
constructs are insert manually by the programmer. This can lead to the issues
described below.

\subsubsection{Dangling References}\label{sec:dangle}
Deallocating storage may lead to dangling references, where some reference 
exists that points to memory that has been deallocated. This is nearly always
unintentional, however it is an easy for a programmer to make this mistake when
writing a program. Using the value of deallocated storage can lead to nefarious
bugs and most languages consider using deallocated storage to
be undefined behaviour.

\lstinputlisting[
    caption={A C program that leaves \texttt{p} pointing to deallocated 
    memory.},
    label={lst:cdangle}
]{codeexamples/dangle.c}

In the Rust programming language, references to values must live longer than
the resource that they refer to~\cite{rust-borrowing}. The same program as the 
C dangling pointer example (Listing~\ref{lst:cdangle}) written in Rust does not
compile as it does not meet this restriction.

\lstinputlisting[
    caption={A Rust program that does not type check.}
]{codeexamples/dangle.rs}

\subsubsection{Memory Leaks}\label{sec:leak}
Memory leaks occur when heap storage that is no longer usable is not
deallocated. This can lead to software allocating more memory for itself and in
the worst case can lead to a program consuming all available memory.

\lstinputlisting[
    caption={A C program which leaks memory.}
]{codeexamples/leak.c}

\subsection{Automatic Memory Management: Garbage Collection}
Techniques have been invented in order to mitigate errors related to manual
memory management. Garbage collection is one such method.  Garbage is a term
for storage that has been allocated on the stack but is no longer reachable by
the program, e.g.\ the storage is pointed to by a variable that has gone out of
scope. Automatic garbage collection alleviates the programmer of explicitly
managing memory. However there are several downsides to garbage collection. For
example, the garbage collector will be invoked to collect unusable memory
outside of the control of the programmer. When it is running it affects the
execution of the program for an indeterminate amount of time. This hang is not
acceptable in real--time systems.

\section{A Solution in the Type System}
Memory safety can still be achieved without the use of a garbage collectors.
Program structure may be analysed during semantic checking and areas likely to
cause issue can be identified. Here Rust's way of performing these checks is
examined.

\subsection{An Introduction to Rust's Model of Memory Management}
Rust, a systems programming language~\cite{rust} is designed to provide memory
safety with no runtime overhead. Rather than relying on a garbage collector to
provide run-time memory safety, Rust relies on strong compile time checks.
This system of compile time checks is referred to as \textit{ownership}, and is
derived from affine type systems and unique pointers to memory
locations\cite{rust-borrowing} \cite{levy2015ownership}.

\subsubsection{Affine types}
Affine types are a development of Linear type systems. Linear type systems
ensure that every variable is used exactly once. In an affine type system, a
variable may be used at most once, i.e.\ zero or one times. This has applications
for managing resources in a program that do not persist the whole time that the
program is running, e.g.\ file handles or heap allocated memory \cite{attapl}
\cite{tovAffine}.

\subsubsection{Ownership}\label{sec:regions}
Values in Rust are bound to a single \textit{owner}, which is the variable to
which it is bound. When the owning variable goes out of scope, the value is
freed. For example:
\begin{lstlisting}[nolol, label={lst:rustScope}]
{
    let x = 69;
}
\end{lstlisting}
When \lstinline{x} goes out of scope the value associated with it will also be
released from memory. Because there can only be a single owner associated with
a value, aliasing a variable is not allowed. This prevents any two parts
of a Rust program from accessing a section of heap memory at the same time.
\begin{lstlisting}[nolol, label={lst:rustScope}]
{
    let x = Thing::new();
    let y = x;
    println("()", x);
}
\end{lstlisting}
The above code does not compile because \lstinline{x} has been moved to
\lstinline{y}, and there is an attempt to use \lstinline{x} in the print
statement. Using a variable as a function argument will also make it not
available for use again. If a function uses some value that has been passing in
as a argument it must return that same value if the scope outside that
function uses it.
\begin{lstlisting}[nolol, label={lst:rustScope}]
// value is comes from outside the scope of this function
fn foo(value: Bar) -> Bar {
    // do stuff with value, returning it and hence handing back ownership
    value
}
\end{lstlisting}
This is not practical, and gets even less practical once there are more
arguments that must be passed back to the caller of the function. To this end
Rust allows references to a value to be created. Creating a reference to a value
in Rust is called borrowing. A reference to a value may be created and passed
in to a function that uses it in some way, and that function does not need to
thread the ownership of that variable back to the caller.
\begin{lstlisting}[nolol, label={lst:rustScope}]
// instead of passing value1 and value2 in by value, create references to values
fn foo(value1: &Bar, value2: &Bar) -> u32 {
    // do stuff with value1 and value2 and return the answer
    123
}
\end{lstlisting}
There are two kinds of borrows: immutable and mutable. There may be many
immutable borrows of a resource at once or a single mutable borrow. This also
prevents heap data from being accessed at the same time at different points in
the program. The scope of borrow must always be shorter than that of the
resource which it borrows. 

This system where resources are freed after the single owner goes out of scope,
as well as borrows always having shorter lifetimes than original resource
mean that Rust can enforce the memory safety of programs. These concepts are
built into the type system.

\section{Representing Programs as Data Structures}
talk about ASTs here

\section{Type checking}
talk about ast tree traversal
